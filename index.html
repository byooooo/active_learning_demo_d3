<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
</head>
<div class="container">
<div class="row justify-content-center">

    <div class="jumbotron">
        <h1>Active Learning Basics with Gaussian Process Regression</h1>      
        
        <p> This narrative visualization demonstrates how active learning can be performed using Gaussian process (GP) regression models. The "true" data in this demo has been generated by sampling from a 1-D sine function with added Gaussian noise. 
        <a href="https://github.com/byooooo/active_learning_demo_d3/blob/master/active_learning_basics.ipynb">A jupyter-notebook of the data generator (in Python) can be found here.</a> </p>
        
        <p>Active learning is a popular method for identifying new training data points when the number of observables is limited. Once training an initial GP model, model retraining is performed sequentially after identifying the next point in search space, which minimizes the overall uncertainty (i.e., maximize information gain) of the model. Note that the (re)trained GP model hyperparameters are static for the purposes of this demo.
        </p>   
        <p>
            Project for UIUC's CS 416 Data Visualization course during the Summer 2021 semester.</p>
        <p>Author: Brian Yoo</p>
    </div>   

    <div class="row">
        <div class="col text-center">
            <button type="button" class="btn btn-outline-dark inline"  onclick="update(-1)">&#8249;</button>
            <button type="button" class="btn btn-outline-dark inline" onclick="update(1)">&#8250;</button>
        </div>

    </div>
</div>




<div class="row justify-content-center">
<body>
    <div id="plot" style="text-align:center"></div>


    <script>

    // set the dimensions + margins
    var margin = {top: 30, right: 30, bottom: 200, left: 60},
        width = 600 - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom

    var iter = 0
    var max_iter = 21

    // create svg
    var svg = d3.select("#plot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")

    // add X axis 
    var x = d3.scaleLinear()
    .domain([0,40])
    .range([ 0, width ])

    svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))

    // add Y axis
    var y = d3.scaleLinear()
    .domain([-2, 2])
    .range([ height, 0 ])
    svg.append("g")
    .call(d3.axisLeft(y))
    
    // add X labels
    svg.append("text")
    .attr("class", "x label")
    .attr("text-anchor", "end")
    .attr("x", (width+margin.left)/2)
    .attr("y", height + margin.top +40 - margin.right)
    .text("input, X")

    // add Y labels
    svg.append("text")
    .attr("class", "y label")
    .attr("text-anchor", "end")
    .attr("x", -width/3.5)
    .attr("y", -40)
    .attr("transform", "rotate(-90)")
    .text("output, y")

    // add iteration count
    var chart_text = "initially sampled data"
    svg.append("text")
    .attr("class", "iteration")
    .attr("text-anchor", "middle")
    .attr("x", width/2)
    .attr("y", margin.top +30 - margin.right)
    .text(chart_text)

    var duration_time = 800

    var old_x = 0
    var old_y = 0

    

    function initialize(){
        //read the data
        d3.csv("initial_xy.csv").then(function(init_data) {

        // set which iteration we want to visualize this should be a callback
        iter = 0

        // Add initial sampled data points
        svg.selectAll(".dot")
        .data(init_data)
        .enter().append("circle")
        .style('opacity', 0.7)
        .attr("r", 3)
        .transition()
        .duration(duration_time)
        .attr("cx", function(d) { return x(d.X) })
        .attr("cy", function(d) { return y(d.y) })

        // this part of the code does not work with bootstrap layouts
        // remove for now

        // .on("mouseover", function(event,d) {
        // var coords = d3.pointer( event )
        // div.transition()
        //     .duration(200)
        //     .style("opacity", .9)
        // div.html("X: "+ d.X + "<br/>" + "y:" +d.y)
        //     .style("left", coords[0] + "px")
        //     .style("top", coords[1]+ "px")
        // })
        // .on("mouseout", function(d) {
        // div.transition()
        //     .duration(500)
        //     .style("opacity", 0)
        //    })
        // })
        // })

        })


    }
            
    function update(shift){               
        iter = iter + shift
        
        // do nothing when check when iteration is out of points
        if (iter <0) {
            iter = 0
            return
        }
        if (iter >max_iter) {
            iter = max_iter
            return
        }

        //read the data
        d3.csv("predictions_all.csv").then(function(data) {
        d3.csv("next_samples.csv").then(function(next_data) {
        d3.csv("initial_xy.csv").then(function(init_data) {

        // clear any annotation
        svg.select("text.nextpoint1").remove()
        svg.select("text.nextpoint2").remove()            
        svg.select("text.band1").remove()
        svg.select("text.band2").remove()
        svg.select("text.mean1").remove()
        svg.select("text.noise").remove()

        // parse data
        data = data.filter(function (d) {return (d.iteration== iter) })
        // note: will need to use .datum() next time we load it to obj

        // clear any points
        d3.selectAll("circle.sampledpoints").remove()
        d3.selectAll("circle.nextpoint").remove()

        
        // when iteration is 0 only show data points
        if (iter==0){
            chart_text = "initially sampled data"
        }
        // when iteration is 1 initialize GP mean and CIs to plot
        else if (iter==1){

            // set chart text
            chart_text = "train a GP model from sampled points"

            // **remove previous GP mean data**
            d3.selectAll("path.mean").remove()
            // append GP mean
            svg
            .append("path")
            .datum(data)
            .attr("class", "mean")
            .attr("fill", "none")
            .attr("stroke", "black")
            .attr("stroke-width", 1.5)
            .transition()
            .duration(duration_time)
            .attr("d", d3.line()
                .x(function(d) { return x(d.X) })
                .y(function(d) { return y(d.pred) })
            )
            // remove exit data to update
            d3.selectAll("path.mean")
            .datum(data).exit().remove()


            // **remove previous CI data**
            d3.selectAll("path.CI").remove()
            // append CI
            svg
            .append("path")
            .datum(data)
            .style('opacity', 0.5)
            .attr("class", "CI")
            .attr("fill", "#1870d5")
            .attr("stroke", "none")
            .transition()
            .duration(duration_time)   
            .attr("d", d3.area()
                .x(function(d) { return x(d.X) })
                .y0(function(d) { return y(d.CI_low) })
                .y1(function(d) { return y(d.CI_high) })
                )
            // remove exit data to update
            d3.selectAll("path.CI")
            .datum(data).exit().remove()

            // Update annotated text
            svg.append("text")
            .attr("class", "band1")
            .attr("text-anchor", "left")
            .attr("x", 80)
            .attr("y", margin.top +325- margin.right)
            .style("font-size", "12px")
            .style("fill", "blue")
            .text("bands are the 95%")

            svg.append("text")
            .attr("class", "band2")
            .attr("text-anchor", "left")
            .attr("x", 80)
            .attr("y", margin.top +345- margin.right)
            .style("font-size", "12px")
            .style("fill", "blue")
            .text("confidence intervals")

            svg.append("text")
            .attr("class", "mean1")
            .attr("text-anchor", "left")
            .attr("x", 80)
            .attr("y", margin.top +300- margin.right)
            .style("font-size", "12px")
            .style("fill", "black")
            .text("line is the GP mean")

        }
        // when iteration is 2 initialize first "next point"
        else if (iter==2){

            chart_text = "active learning cycle: " + (iter-1)

            // **remove previous next data point data**
            d3.selectAll("circle.nextpoint").remove()
            // add next data point
            svg.append("circle")
            .data(next_data).filter(function (d) {return (d.iteration== (iter-1)) })
            .attr("class", "nextpoint")
            .attr("cx", function(d) {return x(d.X)})
            .attr("cy", function(d) {return y(d.y)})
            .attr("r", "4")
            .attr("fill", "red")

            // Update annotated text           
            svg
            .append("text")
            .attr("class", "nextpoint1")
            .attr("text-anchor", "left")
            .attr("x", 100)
            .attr("y", margin.top +225- margin.right)
            .style("font-size", "12px")
            .style("fill", "red")
            .text("sample point with")
            // Update annotated text    
            svg
            .append("text")
            .attr("class", "nextpoint2")
            .attr("text-anchor", "left")
            .attr("x", 100)
            .attr("y", margin.top +245- margin.right)
            .style("font-size", "12px")
            .style("fill", "red")
            .text("highest uncertainty")

        }
        // update annotation only for iterations greater 2
        else if (iter>2){
            // set chart text
            if (iter==3){
                svg
                .append("text")
                .attr("class", "nextpoint2")
                .attr("text-anchor", "left")
                .attr("x", 45)
                .attr("y", margin.top +145- margin.right)
                .style("font-size", "12px")
                .style("fill", "red")
                .text("iterate algorithm")
            }

            if (iter>6 && iter<max_iter){
                svg
                .append("text")
                .attr("class", "noise")
                .attr("text-anchor", "middle")
                .attr("x", width/2)
                .attr("y", margin.top +60 - margin.right)
                .style("font-size", "12px")
                .style("fill", "gray")
                .text("at this point and onward we look to be sampling noise")
            }
            if (iter==max_iter){
                chart_text = "active learning cycle (max): " + (iter-1)
            }
            else {
                chart_text = "active learning cycle: " + (iter-1)
            }

        }
        
        // update for all iterations

        // update annotated text 
        d3.select("text.iteration")
        .text(chart_text)

        // update GP mean
        var gp_mean = d3.selectAll("path.mean")
        .datum(data)
        // remove previous data
        gp_mean.exit().remove()
        // append data
        gp_mean
        .enter()
        .append("path")
        .merge(gp_mean)
        .attr("class", "mean")
        .attr("fill", "none")
        .attr("stroke", "black")
        .attr("stroke-width", 1.5)
        .transition()
        .duration(duration_time)
        .attr("d", 
            d3.line()
            .x(function(d) { return x(d.X) })
            .y(function(d) { return y(d.pred) })
        )


        // add CI data again
        var ci = d3.selectAll("path.CI")
        .datum(data)
        // remove previous data
        ci.exit().remove()
        // append data
        ci
        .enter()
        .append("path")
        .merge(ci)
        .style('opacity', 0.2)
        .attr("class", "CI")
        .attr("fill", "#1870d5")
        .attr("stroke", "none")
        .transition()
        .duration(1000)   
        .attr("d", 
            d3.area()
            .x(function(d) { return x(d.X) })
            .y0(function(d) { return y(d.CI_low) })
            .y1(function(d) { return y(d.CI_high) })
        )

        // add previous sampled points again
        var sampled = svg.selectAll("circle.sampledpoints")
        .data(next_data)
        // remove previous data
        sampled.exit().remove()
        // append data
        sampled
        .enter()
        .filter(function (d) {return (d.iteration< iter-1) })
        .append("circle")
        .merge(sampled)
        .style('opacity', 0.7)
        .attr("class", "sampledpoints")
        .attr("cx", function(d) {return x(d.X)})
        .attr("cy", function(d) {return y(d.y)})
        .attr("r", "3")
        .attr("fill", "black")

        // update next data point to sample again
        var nextsample = svg.selectAll("circle.nextpoint")
        .data(next_data)
        // remove previous data
        nextsample.exit().remove()

        
        .append("circle")
        if (iter-1-shift > 0){
        var prev = next_data.filter(function(d) {return d.iteration==(iter-1-shift)})
        old_x = prev[0].X
        old_y = prev[0].y
        }


        // append data
        nextsample
        .enter()
        .filter(function (d) {return (d.iteration== (iter-1)) })
        .append("circle")
        .merge(nextsample)
        .attr("class", "nextpoint")
        .attr("r", "4")
        .attr("fill", "red")
        .attr("cx", function(d) {return x(old_x)})
        .attr("cy", function(d) {return y(old_y)})
        .transition()
        .duration(500)
        .attr("cx", function(d) {return x(d.X)})
        .attr("cy", function(d) {return y(d.y)})
        

    })
    })
    })
    }

    initialize()

        
    </script>


</body>
</div>

</div> 
</html>