<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
</head>
<div class="container">
<div class="row justify-content-center">

    <div class="jumbotron">
        <h1>Active Learning Basics with Gaussian Process Regression</h1>      
        <p> This narrative visualization demonstrates how active learning is performed using Gaussian process (GP) regression models. The "true" data in this demo has been generated by sampling from a 1-D sine function with added Gaussian noise. Once training an initial GP model, active learning is performed interatively to identify which point to sample next for maximum information gain (i.e., minimum overall uncertainty). All active learning cycles are based on a ("exploration")  sampling strategy that selects the point in search space with highest predicted uncertainty.
        </p>   
        <p>
            Project for UIUC's CS 416 Data Visualization course during the Summer 2021 semester.</p>
        <p>Author: Brian Yoo</p>
    </div>   

    <div class="row">
        <div class="col text-center">
            <button onclick="update(iter-1)">prev</button>
        </div>
        <div class="col text-center">
            <button onclick="update(iter+1)">next</button>
        </div>

    </div>
</div>




<div class="row justify-content-center">
<body>
    <div id="plot" style="text-align:center;"></div>


    <script>

    // set the dimensions + margins
    var margin = {top: 30, right: 30, bottom: 200, left: 60},
        width = 600 - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom;

    var iter = 0
    var max_iter = 21

    // Create svg
    var svg = d3.select("#plot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")

    // Add X axis 
    var x = d3.scaleLinear()
    .domain([0,40])
    .range([ 0, width ]);

    svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x));

    // Add Y axis
    var y = d3.scaleLinear()
    .domain([-2, 2])
    .range([ height, 0 ]);
    svg.append("g")
    .call(d3.axisLeft(y));
    
    // Add X labels
    svg.append("text")
    .attr("class", "x label")
    .attr("text-anchor", "end")
    .attr("x", (width+margin.left)/2)
    .attr("y", height + margin.top +40 - margin.right)
    .text("input, X");

    // Add Y labels
    svg.append("text")
    .attr("class", "y label")
    .attr("text-anchor", "end")
    .attr("x", -width/3.5)
    .attr("y", -40)
    .attr("transform", "rotate(-90)")
    .text("output, y");

    // Add iteration count
    var chart_text = "initially sampled data";
    svg.append("text")
    .attr("class", "iteration")
    .attr("text-anchor", "middle")
    .attr("x", width/2)
    .attr("y", margin.top +30 - margin.right)
    .text(chart_text);

    // var div = d3.select("body").append("div")
    // .attr("class", "tooltip")
    // .style("opacity", 0);

    var duration_time = 800;


    function initialize(){
        //Read the data
        // d3.csv("predictions_all.csv").then(function(data) {
        // d3.csv("next_samples.csv").then(function(next_data) {
        d3.csv("initial_xy.csv").then(function(init_data) {

        // set which iteration we want to visualize this should be a callback
        iter = 0

        // filter data
        // data = data.filter(function (d) {return (d.iteration== iter) })
        // prev_data = next_data.filter(function (d) {return (d.iteration <iter-1) })
        // next_data = next_data.filter(function (d) {return (d.iteration== iter-1) })
        



        // Add initial sampled data points



        svg.selectAll(".dot")
        .data(init_data)
        .enter().append("circle")
        .style('opacity', 0.7)
        .attr("r", 3)
        .attr("cx", function(d) { return x(d.X); })
        .attr("cy", function(d) { return y(d.y); })

        // this part of the code does not work with bootstrap layouts
        // remove for now

        // .on("mouseover", function(event,d) {
        // var coords = d3.pointer( event );
        // div.transition()
        //     .duration(200)
        //     .style("opacity", .9);
        // div.html("X: "+ d.X + "<br/>" + "y:" +d.y)
        //     .style("left", coords[0] + "px")
        //     .style("top", coords[1]+ "px");
        // })
        // .on("mouseout", function(d) {
        // div.transition()
        //     .duration(500)
        //     .style("opacity", 0);
        //    });

        })
        // })
        // })



    }
            
    function update(shifted){               
        iter = shifted
        
        // do nothing when check when iteration is out of points
        if (iter <0) {
            iter = 0
            return
        }
        if (iter >max_iter) {
            iter = max_iter
            return
        }

        //Read the data
        d3.csv("predictions_all.csv").then(function(data) {
        d3.csv("next_samples.csv").then(function(next_data) {
        d3.csv("initial_xy.csv").then(function(init_data) {


        // parse data
        data = data.filter(function (d) {return (d.iteration== iter) })        
        // var prev_data = next_data.filter(function (d) {return (d.iteration< iter-1) });
        // var next_point = next_data.filter(function (d) {return (d.iteration== iter-1) });


        d3.selectAll("circle.sampledpoints").remove();
        d3.selectAll("circle.nextpoint").remove();

        
        // When iteration is 0 only show data points
        if (iter==0){
            chart_text = "initially sampled data"
        }
        // when iteration is 1 initialize GP mean and CIs to plot
        else if (iter==1){

            // set chart text
            chart_text = "train a GP model from sampled points"

            // add GP mean
            // remove previous data
            d3.selectAll("path.mean").remove();
            svg
            .append("path")
            .datum(data)
            .attr("class", "mean")
            .attr("fill", "none")
            .attr("stroke", "black")
            .attr("stroke-width", 1.5)
            .transition()
            .duration(duration_time)
            .attr("d", d3.line()
                .x(function(d) { return x(d.X) })
                .y(function(d) { return y(d.pred) })
            )
            // remove for update
            d3.selectAll("path.mean")
            .datum(data).exit().remove();

            // Add CI
            // remove previous data
            d3.selectAll("path.CI").remove();
            svg
            .append("path")
            .datum(data)
            .style('opacity', 0.5)
            .attr("class", "CI")
            .attr("fill", "#1870d5")
            .attr("stroke", "none")
            .transition()
            .duration(duration_time)   
            .attr("d", d3.area()
                .x(function(d) { return x(d.X) })
                .y0(function(d) { return y(d.CI_low) })
                .y1(function(d) { return y(d.CI_high) })
                )
            // remove for update
            d3.selectAll("path.CI")
            .datum(data).exit().remove();
        }
        // when iteration is 2 initialize first next point
        else if (iter==2){

            chart_text = "active learning cycle: " + (iter-1)
            // add next data point
            d3.selectAll("circle.nextpoint").remove();
            svg
            .append("circle")
            .data(next_data)
            .filter(function (d) {return (d.iteration== iter-1) })
            .attr("class", "nextpoint")
            .attr("cx", function(d) {return x(d.X);})
            .attr("cy", function(d) {return y(d.y);})
            .attr("r", "4")
            .attr("fill", "red")
            // remove for update
            d3.selectAll("circle.nextpoint")
            .data(next_data).exit().remove();
        }

        else if (iter>2){
            // set chart text
            if (iter==max_iter){
                chart_text = "active learning cycle (max): " + (iter-1)
            }
            else {
                chart_text = "active learning cycle: " + (iter-1)
            }
            // update next data point only during this stage
            var nextsample = svg.selectAll("circle.nextpoint")
            .data(next_data);
            
            // nextsample.exit().remove();
            nextsample
            .enter()
            .filter(function (d) {return (d.iteration== iter-1) })
            .append("circle")
            .merge(nextsample)
            .attr("class", "nextpoint")
            .attr("r", "4")
            .attr("fill", "red")
            .attr("cx", function(d) {return x(d.X);})
            .attr("cy", function(d) {return y(d.y);})
        }
        

        
        // Update annotated text
        d3.select("text.iteration")
        .text(chart_text);

        // Update GP mean
        var gp_mean = d3.selectAll("path.mean")
        .datum(data);
        // remove previous data
        gp_mean.exit().remove();
        // add new data
        gp_mean
        .enter()
        .append("path")
        .merge(gp_mean)
        .attr("class", "mean")
        .attr("fill", "none")
        .attr("stroke", "black")
        .attr("stroke-width", 1.5)
        .transition()
        .duration(duration_time)
        .attr("d", d3.line()
            .x(function(d) { return x(d.X) })
            .y(function(d) { return y(d.pred) })
            )



        // Update CI
        var ci = d3.selectAll("path.CI")
        .datum(data);
        // remove previous data
        ci.exit().remove();
        // add new data
        ci
        .enter()
        .append("path")
        .merge(ci)
        .style('opacity', 0.2)
        .attr("class", "CI")
        .attr("fill", "#1870d5")
        .attr("stroke", "none")
        .transition()
        .duration(1000)   
        .attr("d", d3.area()
            .x(function(d) { return x(d.X) })
            .y0(function(d) { return y(d.CI_low) })
            .y1(function(d) { return y(d.CI_high) })
            )




        // Update previous sampled points
        var sampled = svg.selectAll("circle.sampledpoints")
        .data(next_data);
        sampled.exit().remove();
        sampled
        .enter()
        .filter(function (d) {return (d.iteration< iter-1) })
        .append("circle")
        .style('opacity', 0.7)
        .attr("class", "sampledpoints")
        .attr("cx", function(d) {return x(d.X);})
        .attr("cy", function(d) {return y(d.y);})
        .attr("r", "3")
        .attr("fill", "black")




    })
    })
    })
    }

    initialize()

        
    </script>


</body>
</div>

</div> 
</html>